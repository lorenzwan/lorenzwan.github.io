---
sidebar_position: 4
sidebar_class_name: "maya-utilities-menu"
title: "Maya Utilities"
description: "Some Maya commands and tracks that I used."
tags:
  - "Python"
---

:::warning
This page is under construction...
:::

## Overview
This page covers various general-purpose Maya (current using **2024**) commands and tricks that aren't tied to any specific project, primarily using `pymel.core` for its object-oriented structure and improved readability.

[Why PyMEL? â€” PyMEL documentation](https://help.autodesk.com/cloudhelp/2020/CHS/Maya-Tech-Docs/PyMel/why_pymel.html)

### UI related

```python copy showLineNumbers
from PySide2.QtWidgets import QMainWindow
from shiboken2 import wrapInstance
import maya.OpenMayaUI as omui

def getMainWindow() -> QMainWindow:
    """Get Maya main window and wrap it as QMainWindow."""
    return wrapInstance(int(omui.MQtUtil.mainWindow()), QMainWindow)
```
### Scene related

```python copy showLineNumbers
from pathlib import Path
import pymel.core as pm

def cleanNanFloat(filepath: Path | str | None = None):
    """
    Clean up nan from a scene.

    :param filepath: the path of the maya scene
    :raises RuntimeError: If given path isn't a .ma
    """
    if filepath is None:
        filepath = pm.sceneName()
    filepath = Path(filepath)
    if filepath.suffix != ".ma":
        raise RuntimeError(f"The given path {filepath} is not a .ma.")
    
    with open(filepath, "r") as ma:
        text = ma.read()
    
    # Some online cases contain "-nan(ind)", I haven't seen it so far
    with open(filepath, "w") as ma:
        ma.write(text.replace(" nan", " 0"))

    pm.openFile(filepath, force=True)


def deleteUnknownNodes():
    """Remove all unknown nodes in the scene, like Mental Ray node from old Maya. """
    unknownNodes: list[pm.PyNode] = pm.ls(type='unknown')
    if unknownNodes:
        print(f"Deleteing {unknownNodes}")
        pm.lockNode(unknownNodes, lock=False)
        pm.delete(unknownNodes)
        print('All unknown nodes are removed')
```

### Attr related

```python copy showLineNumbers
import pymel.core as pm

def reindexMultiAttribute(attribute: pm.PyNode):
    """
    Reindex the connections in the multi attribute with no gaps.

    :param attribute: Multi attribute
    """
    connections: list[list[pm.PyNode]] = attribute.listConnections(connections=True, plugs=True)
    for index, connection in enumerate(connections):
        thisPlug, inputPlug = connection
        inputPlug // thisPlug
        inputPlug >> attribute[index]
```

### Transform related

```python copy showLineNumbers
import pymel.core as pm
import maya.api.OpenMaya as om

def getBoundingBoxCenter(objects: pm.PyNode) -> tuple[float]:
    """Calculate bounding box center of objects"""
    bb: list[float] = pm.exactWorldBoundingBox(objects)
    return (bb[0] + bb[3]) / 2, (bb[1] + bb[4]) / 2, (bb[2] + bb[5]) / 2

def getCenterPositionBetweenTwo(objectA: pm.PyNode, objectB: pm.PyNode) -> om.MVector: 
    """Calculate the center position between two objects"""
    startVector = om.MVector(pm.xform(objectA, query=True, translation=True, worldSpace=True))
    endVector = om.MVector(pm.xform(objectB, query=True, translation=True, worldSpace=True))
    return (startVector + endVector) / 2
```

### Mesh related

```python copy showLineNumbers
import pymel.core as pm

def seperateMeshesByMaterial(meshes: list[pm.PyNode] | None = None):
    """
    Find faces from given meshes based on the shading engine node, and extract the faces.

    :param meshes: a list of transform nodes to process
    """
    if not meshes:
        meshes = pm.selected()

    shapes: list[pm.PyNode] = [mesh.getShape() for mesh in meshes]
    # Get all shadingEngine nodes from the given meshes
    shadingEngines: list[pm.PyNode] = []
    for mesh in meshes:
        for shadingEngine in mesh.getShape().inputs(type="shadingEngine"):
            shadingEngines.append(shadingEngine)
    shadingEngines = list(set(shadingEngines))

    # Find faces from shading engine
    for shadingEngine in shadingEngines:
        shapeAndMeshFaceDict: dict[pm.PyNode, list[pm.PyNode]] = {}
        members = pm.sets(shadingEngine, query=True) # It returns all the faces in the scene
        
        # Orginize the data
        for member in members:
            shapeNode = member.node()
            if shapeNode not in shapes:
                # Skip if it is not part of the given mesh
                continue
            shapeAndMeshFaceDict.setdefault(shapeNode, []).append(member)
        
        # Extract faces for each shape
        materialName = shadingEngine.surfaceShader.inputs()[0]
        for shapeNode, meshFaces in shapeAndMeshFaceDict.items():
            extractFaces(shapeNode, meshFaces, materialName)


def extractFaces(shapeNode: pm.PyNode, meshFaces: list[pm.PyNode], preffix: str) -> pm.PyNode:
    """
    Duplicate the given mesh, add preffix to the new mesh,
    and remove the faces that are not part of the given faces.

    :param shapeNode: the orginal node
    :param meshFaces: a list of MeshFace objects, looks like MeshFace('BobShape.f[0:123]')
    :param preffix: the preffix of the new mesh name
    """
    shapeNodeName = shapeNode.getName()
    transformNode = shapeNode.getParent()
    transformNodeName = transformNode.getName()
    newNodeName = f"{preffix}_{transformNodeName}"
    newTransformNode = pm.duplicate(shapeNode, name=newNodeName)[0]
    newShapeNode = newTransformNode.getShape()
    newShapeNodeName = newShapeNode.getName()
    
    # The given meshFaces are based on the orginal mesh. Updates the name for the duplicated mesh.
    facesToSelect = [str(meshFace).replace(shapeNodeName, newShapeNodeName) for meshFace in meshFaces]
    pm.select(facesToSelect, replace=True)
    pm.select(f"{newShapeNodeName}.f[*]", toggle=True) # Invert select
    if pm.selected():
        pm.polyDelFacet(pm.selected())
        pm.bakePartialHistory(newShapeNodeName)
    
    return newTransformNode
```

### Rigging related

```python copy showLineNumbers
import math
import pymel.core as pm
import maya.api.OpenMaya as om

def getPVPosition(jointChain: list[pm.PyNode], distance: float = 1.0) -> om.MVector:
    """
    Calculate the a pole vector position for a planar joint chain.

    :param jointChain: list of joints (all should lie on the same plane)
    :param distance: distance multiplier
    :return: position in world space
    """
    startVector = om.MVector(pm.xform(jointChain[0], query=True, translation=True, worldSpace=True))
    endVector = om.MVector(pm.xform(jointChain[-1], query=True, translation=True, worldSpace=True))

    # Get an average position of the in between joints
    # Support joint chain with more than 3 joints.
    inBetweenJoints = jointChain[1:-1]
    middleVector = om.MVector()
    for joint in inBetweenJoints:
        middleVector += om.MVector(pm.xform(joint, query=True, translation=True, worldSpace=True))
    middleVector /= len(inBetweenJoints)

    # Find the position between the start and end based on the middle position
    # Vector projection of one vector onto another
    uVector = middleVector - startVector
    vVector = endVector - startVector
    angleTheta = uVector.angle(uVector)
    projDistance = math.cos(angleTheta) * uVector.length()
    projPosition = startVector + (vVector.normal() * projDistance)

    # Move the projected point through the middle position
    return projPosition + (middleVector - projPosition).normal() * (vVector.length() * distance)
```